export const meta = {
	title: "Best GraphQL Stack for a TypeScript Dev",
	author: "David Lee"
};

# Best GraphQL Stack for a TypeScript Dev

February 19, 2021

*Disclaimer: This post reflects my personal experience as a [TypeScript](https://www.typescriptlang.org/) developer.*

If you're looking to start a [GraphQL](https://graphql.org/) project using [Node.js](https://nodejs.org/en/), I would recommend using [Urql](https://formidable.com/open-source/urql/), [Nexus](https://nexusjs.org/), [Prisma](https://www.prisma.io/) and [GraphQL Codegen](https://graphql-code-generator.com/).

Obviously, depending on your project and personal preferences, other tools might make more sense; however, I can at least attest to my own developer experience (DX) with the stack above.

## Nexus + Prisma

If you've gone through the same GraphQL journey as I have: originally defining your schema and resolvers directly with [graphql-js](https://github.com/graphql/graphql-js) and eventually taking the SDL approach offered by [graphql-tools](https://www.graphql-tools.com/docs/introduction/); then you've likely also experienced the same pain-points as I have:

1. Lackluster TypeScript support
2. Overly verbose schema definition (in the case of graphql-js)
3. Separate maintenance of the SDL from the resolvers in large schemas

Similarly, if you've worked with [sequelize](https://sequelize.org/) or [mongoose](https://mongoosejs.com/docs/), you've likely also dealt with the pains of poor TypeScript support, especially when querying for nested entities in your databases.

Thankfully, Nexus + Prisma were built with all of these considerations in mind.

1. With advanced use of [type generics](https://www.typescriptlang.org/docs/handbook/generics.html) and code-generation, both have first-class support for TypeScript.
2. Nexus's API aims to emulate the feel of writing the GraphQL SDL through code, which allows us to cut down on overly verbose schema definitions.
3. Nexus's code-first approach puts the schema definition and resolvers in the same place  in code.

*More benefits can be found on the Nexus + Prisma websites*

### Nexus + Prisma examples

*Example of defining your database models with prisma*
```markup
datasource db {
	provider = "postgresql"
	url      = env("DATABASE_URL")
}

generator client {
	provider = "prisma-client-js"
}

enum UserAllegiance {
	NEUTRAL
	ALLIANCE
	HORDE
}

model User {
	id        Int      @id @default(autoincrement())
	email     String   @unique
	firstName String
	lastName  String
	// Example of optional field
	imageUrl  String?
	alliance  UserAllegiance @default(NEUTRAL)
	// Relation example
	posts     Post[]
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	// Example of compound index constraint
	@@unique([firstName, lastName])
}

model Post {
	id       Int @id @default(autoincrement())
	title    String
	content  String
	// Relation example
	author   User @relation(fields: [authorId], references: [id])
	authorId Int
}
```

*Example of GraphQL with nexus*
```typescript
import { GraphQLSchema } from "graphql";
import { arg, makeSchema, mutationType, objectType, queryType } from "nexus";
import { nexusPrisma } from "nexus-plugin-prisma";

const User = objectType({
	name: "User",
	description: "A user of our application",
	definition: (t) => {
		// t.model auto-generates the types/resolvers from our database
		t.model("id");
		t.model("email");
		t.model("firstName");
		t.model("lastName");
		t.model("imageUrl");
		t.model("alliance");
		t.model("posts");
		t.model("createdAt");
		t.model("updatedAt");
		t.nonNull.string("fullName", {
			resolve: (parent, args, ctx, info) => {
				// parent, args and ctx are all extensively typed
				const { firstName, lastName } = parent;

				return [firstName, lastName].join(" ");
			}
		});
		t.nonNull.number("countPosts", {
			resolve: async (parent, args, ctx, info) => {
				const { id } = parent;
				const { prisma } = ctx;

				return await prisma.post.count({ where: { authorId: id } });
			}
		});
	}
});

const Post = objectType({
	name: "Post",
	description: "Comment/Post, made by a User",
	definition: (t) => {
		t.model("id");
		t.model("title");
		t.model("content");
		t.model("author");
		t.model("authorId");
	}
});

const Query = queryType({
	description: "Root query type",
	definition: (t) => {
		t.nonNull.boolean("ok", { resolve: () => true });
		// t.crud auto-generates types/resolvers for queries/mutations
		t.crud.user();
		t.crud.users();
		t.crud.post();
		t.crud.posts();
		// You can also define custom resolvers
		t.nonNull.number("countPosts", {
			args: {
				// PostWhereInput is generated by t.crud.posts()
				where: arg({ type: "PostWhereInput" })
			},
			resolve: async (parent, args, ctx, info) => {
				// parent, args and ctx are all extensively typed
				const { where } = args;
				const { prisma } = ctx;

				return await prisma.post.count({ where });
			}
		});
	}
});

const Mutation = mutationType({
	description: "Root mutation type",
	definition: (t) => {
		t.nonNull.boolean("ok", { resolve: () => true });
		t.crud.createOneUser();
		t.crud.deleteOneUser();
		t.crud.updateOneUser();
		t.crud.upsertOneUser();
		t.crud.createOnePost();
		t.crud.deleteOnePost();
		t.crud.updateOnePost();
		t.crud.upsertOnePost();
	}
});

// This is just a GraphQLSchema type; use any gql server solution you like
export const schema: GraphQLSchema = makeSchema({
	shouldGenerateArtifacts: true,
	shouldExitAfterGenerateArtifacts: false,
	types: { User, Post, Query, Mutation },
	outputs: {
		schema: "schemaPath",
		typegen: "typingsPath"
	},
	plugins: [
		nexusPrisma({
			experimentalCrud: true,
			outputs: "prismaTypingsPath",
			paginationStrategy: "prisma",
			prismaClient: (ctx) => ctx.prisma
		})
	],
	sourceTypes: {
		headers: [],
		modules: []
	},
	contextType: {
		module: "@myapp/server/graphql/context",
		export: "GraphQLServerContext",
		alias: "ctx"
	}
});
```
*More docs on the Nexus and Prisma websites*

```typescript
import { context, GraphQLServerContext } from "@myapp/server/graphql/context";
import { schema } from "@myapp/server/graphql/schema";
import { ApolloServer } from "apollo-server-micro";

export const apolloServer = new ApolloServer({
	context,
	schema
});
```

## GraphQL on the client

For [Toastel](https://toastel.com), I've actually used [ApolloClient](https://www.apollographql.com/docs/react/) for my client-side GraphQL needs. However, after having read the docs and trying [Urql](https://formidable.com/open-source/urql/), I regret not having started with Urql instead.

ApolloClient, along with several custom [links](https://www.apollographql.com/docs/react/api/link/introduction/), occupies between 30 - 40kB gzipped on my client bundle, compared to Urql's 10 - 20kB.

From an API perspective, Urql also feels remarkably similar to ApolloClient in all of: the GraphQL client, React hooks and caching.

Setting up authentication, retries and caching also felt easier with [exchanges](https://formidable.com/open-source/urql/docs/concepts/exchanges/) and Urql's extensive documentation, whereas Apollo's felt lacking in some places.

*Urql provides more comparisons between it and Apollo/Relay on [their site](https://formidable.com/open-source/urql/docs/comparison/).*

### Typed client-side queries

As we've already improved our TypeScript DX on the server, we might as well do the same on the client.

Let's say that we have a component that renders a list of posts.

```tsx
import { Post } from "@prisma/client";
import React, { FC } from "react";
import { useQuery } from "urql";

export interface PostListProps {
	userId: number;
}

export const PostList: FC<PostListProps> = ({ userId }) => {
	const [result] = useQuery<{ posts: Post[] }>({
		query: `
			query GetPosts($userId: Int!) {
				posts(where: { id: $userId }) {
					id
					title
				}
			}
		`,
		variables: { userId }
	});

	const { data, fetching, error } = result;

	if (fetching) return <p>Loading...</p>;
	if (error) return <p>Oh no... {error.message}</p>;
	if (!data) return <p>Something went wrong</p>;

	return (
		<ul>
			{data.posts.map((post) => (
				<li key={post.id}>
					<span>{post.title}</span>
					{/* Oh no! We don't have content, but we passed static analysis! */}
					<span>{post.content}</span>
				</li>
			))}
		</ul>
	);
};
```

In the code example above, the type we passed to `useQuery` does not match the query string. So we not only had to define our `useQuery` type, but also static analysis failed to catch the error we left in.

We can resolve this by using [GraphQL Codegen](https://graphql-code-generator.com/).

```yaml
# codegen.yml file

overwrite: true
schema:
	- graphqlSchemaPathHere
documents: "./src/client/graphql/**/*.{fragment,mutation,query}.{ts,graphql}"
generates:
	./src/client/graphql/generated/graphql.tsx
		plugins:
			- time:
				message: "This file was generated on: "
				format: MMM Do YYYY h:mm:ss a
			- typescript
			- typescript-operations
			- typescript-urql
	./src/client/graphql/generated/schema.gen.graphql
		plugins:
			- time:
			- schema-ast:
				commentDescriptions: true
```

```graphql
# get-posts.query.graphql file

query GetPosts($userId: Int!) {
	posts(where: { id: $userId }) {
		id
		title
	}
}
```

```tsx
/* ... */

export const PostList: FC<PostListProps> = ({ userId }) => {
	/* Now we'll catch that we're missing a property, without needing to maintain typedefs */
	const [result] = useGetPostsQuery({ variables: { userId } });

/* ... */
```

With this, not only have we improved our TypeScript DX on the server, but we also achieved a similar DX on the client with an API much like ApolloClient at a fraction of the added bundle size.

Happy coding! -- David Lee
